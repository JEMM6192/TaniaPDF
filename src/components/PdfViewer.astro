---
import "../assets/styles.css";
---

<div id="mainContainer">
  <div id="viewerContainer">
    <div id="pdfContainer">
      <canvas id="pdfCanvas"></canvas>
      <canvas id="overlayCanvas"></canvas>
    </div>
  </div>
  <div id="controlPanel">
    <button id="btnAbrir">Abrir PDF</button>
    <button id="btnZoomIn">Acercar</button>
    <button id="btnZoomOut">Alejar</button>
    <button id="btnAgregarMarca">Agregar Marca</button>
    <button id="btnImprimir">Imprimir</button>
    <button id="btnGuardar">Guardar</button>
    <div id="marksListContainer">
      <div id="marksList"></div>
    </div>
  </div>
</div>

<!-- Add these script tags to load the libraries -->
<script
  is:inline
  src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"
></script>
<script
  is:inline
  src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"
></script>
<script is:inline>
  // Set the worker source for PDF.js
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
</script>

<!-- Bloque inline para importar y ejecutar el módulo en el cliente -->
<script>
  // Type declarations for external libraries
  declare const pdfjsLib: any;
  declare const jspdf: { jsPDF: any };

  // Define interfaces for our types
  interface Marca {
    x: number;
    y: number;
    width: number;
    height: number;
    color: string;
  }

  interface CurrentMarca {
    startX: number;
    startY: number;
  }

  document.addEventListener("DOMContentLoaded", () => {
    // Initialize variables once with proper types
    let pdfDoc: any = null;
    let currentPage = 1;
    let scale = 1.0;

    const pdfCanvas = document.getElementById("pdfCanvas") as HTMLCanvasElement;
    const ctxPdf = pdfCanvas?.getContext("2d");
    const overlayCanvas = document.getElementById(
      "overlayCanvas"
    ) as HTMLCanvasElement;
    const ctxOverlay = overlayCanvas?.getContext("2d");
    const viewerContainer = document.getElementById("viewerContainer");

    // Variable para guardar el nombre del PDF abierto
    let pdfFileName = "";

    // Variables para marcas (coordenadas en relación a la página original)
    let marcas: Marca[] = [];
    let isMarcando = false;
    let currentMarca: CurrentMarca | null = null;
    let selectedMarkIndex: number | null = null;

    // Panning: variables para arrastrar en el visualizador
    let isPanning = false;
    let startPan = { x: 0, y: 0 };
    let startScroll = { left: 0, top: 0 };

    function actualizarOverlay(): void {
      if (overlayCanvas && pdfCanvas) {
        overlayCanvas.width = pdfCanvas.width;
        overlayCanvas.height = pdfCanvas.height;
      }
    }

    function renderPage(num: number): void {
      if (!pdfDoc) return;

      pdfDoc.getPage(num).then(function (page: any) {
        const viewport = page.getViewport({ scale: scale });
        if (pdfCanvas) {
          pdfCanvas.width = viewport.width;
          pdfCanvas.height = viewport.height;
        }
        actualizarOverlay();
        const renderContext = {
          canvasContext: ctxPdf,
          viewport: viewport,
        };
        page.render(renderContext).promise.then(function () {
          dibujarMarcasFijas();
        });
      });
    }

    function dibujarMarcasFijas(): void {
      if (!ctxOverlay || !overlayCanvas) return;

      ctxOverlay.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      marcas.forEach((marca) => {
        if (ctxOverlay) {
          ctxOverlay.strokeStyle = marca.color;
          ctxOverlay.lineWidth = 2;
          ctxOverlay.setLineDash([]);
          ctxOverlay.strokeRect(
            marca.x * scale,
            marca.y * scale,
            marca.width * scale,
            marca.height * scale
          );
        }
      });
      updateMarksList();
    }

    function updateMarksList(): void {
      const listDiv = document.getElementById("marksList");
      if (!listDiv) return;

      listDiv.innerHTML = "";
      marcas.forEach((marca, idx) => {
        const container = document.createElement("div");
        container.dataset.index = idx.toString();

        // Recuadro de color
        const colorBox = document.createElement("div");
        colorBox.className = "colorBox";
        colorBox.style.backgroundColor = marca.color;

        // Etiqueta
        const label = document.createElement("span");
        label.className = "markLabel";
        label.textContent = "Marca " + (idx + 1);
        label.addEventListener("click", () => {
          selectedMarkIndex = idx;
          if (listDiv) {
            listDiv
              .querySelectorAll("div")
              .forEach((el) => el.classList.remove("selected"));
          }
          container.classList.add("selected");
        });

        // Botón de eliminar con ícono
        const deleteBtn = document.createElement("img");
        deleteBtn.className = "deleteBtn";
        deleteBtn.src = "icons/delete.svg"; // Asegúrate de que el archivo se encuentre en public/icons/
        deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          if (container.dataset.index) {
            const index = parseInt(container.dataset.index, 10);
            marcas.splice(index, 1);
            if (selectedMarkIndex === index) {
              selectedMarkIndex = null;
            }
            updateMarksList();
            dibujarMarcasFijas();
          }
        });

        container.appendChild(colorBox);
        container.appendChild(label);
        container.appendChild(deleteBtn);
        listDiv.appendChild(container);
      });
    }

    // Función para exportar (guardar o imprimir) una marca en alta calidad
    function exportMarca(
      mark: Marca,
      callback: (imgData: string, cropW: number, cropH: number) => void
    ): void {
      if (!pdfDoc) return;

      const exportScale = 3.0;
      pdfDoc.getPage(currentPage).then(function (page: any) {
        const viewportHigh = page.getViewport({ scale: exportScale });
        const highCanvas = document.createElement("canvas");
        highCanvas.width = viewportHigh.width;
        highCanvas.height = viewportHigh.height;
        const highCtx = highCanvas.getContext("2d");
        const renderContext = {
          canvasContext: highCtx,
          viewport: viewportHigh,
        };

        page.render(renderContext).promise.then(function () {
          const cropX = mark.x * exportScale;
          const cropY = mark.y * exportScale;
          const cropW = mark.width * exportScale;
          const cropH = mark.height * exportScale;

          const cropCanvas = document.createElement("canvas");
          cropCanvas.width = cropW;
          cropCanvas.height = cropH;
          const cropCtx = cropCanvas.getContext("2d");

          if (cropCtx) {
            cropCtx.drawImage(
              highCanvas,
              cropX,
              cropY,
              cropW,
              cropH,
              0,
              0,
              cropW,
              cropH
            );
          }

          callback(cropCanvas.toDataURL("image/png"), cropW, cropH);
        });
      });
    }

    function processMark(i: number): void {
      let pdf: any = null;
      let processed = 0;

      exportMarca(
        marcas[i],
        (imgData: string, cropW: number, cropH: number) => {
          const orientation = cropW > cropH ? "landscape" : "portrait";
          const { jsPDF } = jspdf;

          if (i === 0) {
            pdf = new jsPDF({
              orientation: orientation,
              unit: "px",
              format: [cropW, cropH],
            });
            pdf.addImage(imgData, "PNG", 0, 0, cropW, cropH);
          } else {
            pdf.addPage([cropW, cropH], orientation);
            pdf.addImage(imgData, "PNG", 0, 0, cropW, cropH);
          }

          processed++;
          if (processed === marcas.length) {
            const baseName = pdfFileName.replace(/\.[^/.]+$/, "");
            pdf.save(baseName + "_marcas.pdf");
          } else {
            processMark(i + 1);
          }
        }
      );
    }

    // Event Listeners
    const btnAbrir = document.getElementById("btnAbrir");
    if (btnAbrir) {
      btnAbrir.addEventListener("click", () => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "application/pdf";
        input.onchange = (e) => {
          const target = e.target as HTMLInputElement;
          if (target && target.files && target.files[0]) {
            const file = target.files[0];
            pdfFileName = file.name;
            const fileReader = new FileReader();
            fileReader.onload = function (this: FileReader) {
              const typedarray = new Uint8Array(this.result as ArrayBuffer);
              pdfjsLib
                .getDocument(typedarray)
                .promise.then(function (pdf: any) {
                  pdfDoc = pdf;
                  currentPage = 1;
                  scale = 1.0;
                  marcas = [];
                  selectedMarkIndex = null;
                  renderPage(currentPage);
                })
                .catch(function (error: Error) {
                  console.error("Error al cargar PDF:", error);
                  alert("Error al cargar el PDF. Revisa la consola.");
                });
            };
            fileReader.readAsArrayBuffer(file);
          }
        };
        input.click();
      });
    }

    const btnZoomIn = document.getElementById("btnZoomIn");
    if (btnZoomIn) {
      btnZoomIn.addEventListener("click", () => {
        scale *= 1.1;
        renderPage(currentPage);
      });
    }

    const btnZoomOut = document.getElementById("btnZoomOut");
    if (btnZoomOut) {
      btnZoomOut.addEventListener("click", () => {
        scale /= 1.1;
        renderPage(currentPage);
      });
    }

    const btnAgregarMarca = document.getElementById("btnAgregarMarca");
    if (btnAgregarMarca) {
      btnAgregarMarca.addEventListener("click", () => {
        isMarcando = true;
        if (overlayCanvas) {
          overlayCanvas.style.cursor = "crosshair";
        }
      });
    }

    // Imprimir Marca(s): genera un PDF con una página por cada marca y lo abre en una nueva pestaña
    const btnImprimir = document.getElementById("btnImprimir");
    if (btnImprimir) {
      btnImprimir.addEventListener("click", () => {
        if (marcas.length === 0) {
          alert("No hay marcas para imprimir.");
          return;
        }

        let pdf: any = null;
        let processed = 0;

        function processMarkForPrint(i: number): void {
          exportMarca(
            marcas[i],
            (imgData: string, cropW: number, cropH: number) => {
              const orientation = cropW > cropH ? "landscape" : "portrait";
              const { jsPDF } = jspdf;

              if (i === 0) {
                pdf = new jsPDF({
                  orientation: orientation,
                  unit: "px",
                  format: [cropW, cropH],
                });
                pdf.addImage(imgData, "PNG", 0, 0, cropW, cropH);
              } else {
                pdf.addPage([cropW, cropH], orientation);
                pdf.addImage(imgData, "PNG", 0, 0, cropW, cropH);
              }

              processed++;
              if (processed === marcas.length) {
                const pdfBlob = pdf.output("blob");
                const blobUrl = URL.createObjectURL(pdfBlob);
                window.open(blobUrl, "_blank");
              } else {
                processMarkForPrint(i + 1);
              }
            }
          );
        }

        processMarkForPrint(0);
      });
    }

    // Guardar Marca(s): genera y descarga un PDF con todas las marcas
    const btnGuardar = document.getElementById("btnGuardar");
    if (btnGuardar) {
      btnGuardar.addEventListener("click", () => {
        if (marcas.length === 0) {
          alert("No hay marcas para guardar.");
          return;
        }

        let pdf: any = null;
        let processed = 0;

        function processMarkForSave(i: number): void {
          exportMarca(
            marcas[i],
            (imgData: string, cropW: number, cropH: number) => {
              const orientation = cropW > cropH ? "landscape" : "portrait";
              const { jsPDF } = jspdf;

              if (i === 0) {
                pdf = new jsPDF({
                  orientation: orientation,
                  unit: "px",
                  format: [cropW, cropH],
                });
                pdf.addImage(imgData, "PNG", 0, 0, cropW, cropH);
              } else {
                pdf.addPage([cropW, cropH], orientation);
                pdf.addImage(imgData, "PNG", 0, 0, cropW, cropH);
              }

              processed++;
              if (processed === marcas.length) {
                const baseName = pdfFileName.replace(/\.[^/.]+$/, "");
                pdf.save(baseName);
              } else {
                processMarkForSave(i + 1);
              }
            }
          );
        }

        processMarkForSave(0);
      });
    }

    if (overlayCanvas) {
      overlayCanvas.addEventListener("mousedown", (e) => {
        if (isMarcando) {
          const rect = overlayCanvas.getBoundingClientRect();
          currentMarca = {
            startX: e.clientX - rect.left,
            startY: e.clientY - rect.top,
          };
        }
      });

      overlayCanvas.addEventListener("mousemove", (e) => {
        if (isMarcando && currentMarca && ctxOverlay) {
          const rect = overlayCanvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          dibujarMarcasFijas();
          ctxOverlay.save();
          ctxOverlay.strokeStyle = "black";
          ctxOverlay.setLineDash([5, 3]);
          const width = mouseX - currentMarca.startX;
          const height = mouseY - currentMarca.startY;
          ctxOverlay.strokeRect(
            currentMarca.startX,
            currentMarca.startY,
            width,
            height
          );
          ctxOverlay.restore();
        }
      });

      overlayCanvas.addEventListener("mouseup", (e) => {
        if (isMarcando && currentMarca) {
          const rect = overlayCanvas.getBoundingClientRect();
          const endX = e.clientX - rect.left;
          const endY = e.clientY - rect.top;
          const x = Math.min(currentMarca.startX, endX) / scale;
          const y = Math.min(currentMarca.startY, endY) / scale;
          const width = Math.abs(endX - currentMarca.startX) / scale;
          const height = Math.abs(endY - currentMarca.startY) / scale;
          const colors = ["red", "blue", "green", "orange", "purple", "brown"];
          const color = colors[marcas.length % colors.length];
          marcas.push({ x, y, width, height, color });
          isMarcando = false;
          currentMarca = null;
          if (overlayCanvas) {
            overlayCanvas.style.cursor = "default";
          }
          dibujarMarcasFijas();
        }
      });
    }

    // Panning: desplazar el visualizador cuando no se está marcando
    if (viewerContainer) {
      viewerContainer.addEventListener("mousedown", (e) => {
        if (!isMarcando) {
          isPanning = true;
          if (viewerContainer) {
            viewerContainer.style.cursor = "grabbing";
          }
          startPan = { x: e.clientX, y: e.clientY };
          if (viewerContainer) {
            startScroll = {
              left: viewerContainer.scrollLeft,
              top: viewerContainer.scrollTop,
            };
          }
        }
      });
    }

    window.addEventListener("mousemove", (e) => {
      if (isPanning && viewerContainer) {
        const dx = e.clientX - startPan.x;
        const dy = e.clientY - startPan.y;
        viewerContainer.scrollLeft = startScroll.left - dx;
        viewerContainer.scrollTop = startScroll.top - dy;
      }
    });

    window.addEventListener("mouseup", () => {
      if (isPanning && viewerContainer) {
        isPanning = false;
        viewerContainer.style.cursor = "grab";
      }
    });
  });
</script>
